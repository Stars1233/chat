import { isJSX, toModalElement } from "./jsx-runtime";
import { Message, type SerializedMessage } from "./message";
import type { ModalElement } from "./modals";
import { type SerializedThread, ThreadImpl } from "./thread";
import type {
  ActionEvent,
  ActionHandler,
  Adapter,
  Author,
  ChatConfig,
  ChatInstance,
  EmojiValue,
  Logger,
  LogLevel,
  MentionHandler,
  MessageHandler,
  ModalCloseEvent,
  ModalCloseHandler,
  ModalResponse,
  ModalSubmitEvent,
  ModalSubmitHandler,
  ReactionEvent,
  ReactionHandler,
  StateAdapter,
  SubscribedMessageHandler,
  Thread,
  WebhookOptions,
} from "./types";
import { ChatError, ConsoleLogger, LockError } from "./types";

const DEFAULT_LOCK_TTL_MS = 30_000; // 30 seconds
/** TTL for message deduplication entries */
const DEDUPE_TTL_MS = 60_000; // 60 seconds

interface MessagePattern<TState = Record<string, unknown>> {
  pattern: RegExp;
  handler: MessageHandler<TState>;
}

/** Filter can be EmojiValue objects, emoji names, or raw emoji formats */
type EmojiFilter = EmojiValue | string;

interface ReactionPattern {
  /** If specified, only these emoji trigger the handler. Empty means all emoji. */
  emoji: EmojiFilter[];
  handler: ReactionHandler;
}

interface ActionPattern {
  /** If specified, only these action IDs trigger the handler. Empty means all actions. */
  actionIds: string[];
  handler: ActionHandler;
}

interface ModalSubmitPattern {
  callbackIds: string[];
  handler: ModalSubmitHandler;
}

interface ModalClosePattern {
  callbackIds: string[];
  handler: ModalCloseHandler;
}

/**
 * Type-safe webhook handler that is available for each adapter.
 */
type WebhookHandler = (
  request: Request,
  options?: WebhookOptions,
) => Promise<Response>;

/**
 * Creates a type-safe webhooks object based on the adapter names.
 */
type Webhooks<TAdapters extends Record<string, Adapter>> = {
  [K in keyof TAdapters]: WebhookHandler;
};

/**
 * Main Chat class with type-safe adapter inference and custom thread state.
 *
 * @template TAdapters - Map of adapter names to Adapter instances
 * @template TState - Custom state type stored per-thread (default: Record<string, unknown>)
 *
 * @example
 * // Define custom thread state type
 * interface MyThreadState {
 *   aiMode?: boolean;
 *   userName?: string;
 * }
 *
 * const chat = new Chat<typeof adapters, MyThreadState>({
 *   userName: "mybot",
 *   adapters: {
 *     slack: createSlackAdapter({ ... }),
 *     teams: createTeamsAdapter({ ... }),
 *   },
 *   state: createMemoryState(),
 * });
 *
 * // Type-safe thread state
 * chat.onNewMention(async (thread, message) => {
 *   await thread.setState({ aiMode: true });
 *   const state = await thread.state; // Type: MyThreadState | null
 * });
 */
export class Chat<
  TAdapters extends Record<string, Adapter> = Record<string, Adapter>,
  TState = Record<string, unknown>,
> implements ChatInstance
{
  private adapters: Map<string, Adapter>;
  private _stateAdapter: StateAdapter;
  private userName: string;
  private logger: Logger;
  private _streamingUpdateIntervalMs: number;

  private mentionHandlers: MentionHandler<TState>[] = [];
  private messagePatterns: MessagePattern<TState>[] = [];
  private subscribedMessageHandlers: SubscribedMessageHandler<TState>[] = [];
  private reactionHandlers: ReactionPattern[] = [];
  private actionHandlers: ActionPattern[] = [];
  private modalSubmitHandlers: ModalSubmitPattern[] = [];
  private modalCloseHandlers: ModalClosePattern[] = [];

  /** Initialization state */
  private initPromise: Promise<void> | null = null;
  private initialized = false;

  /**
   * Type-safe webhook handlers keyed by adapter name.
   * @example
   * chat.webhooks.slack(request, { backgroundTask: waitUntil });
   */
  public readonly webhooks: Webhooks<TAdapters>;

  constructor(config: ChatConfig<TAdapters>) {
    this.userName = config.userName;
    this._stateAdapter = config.state;
    this.adapters = new Map();
    this._streamingUpdateIntervalMs = config.streamingUpdateIntervalMs ?? 500;

    // Initialize logger
    if (typeof config.logger === "string") {
      this.logger = new ConsoleLogger(config.logger as LogLevel);
    } else {
      this.logger = config.logger;
    }

    // Register adapters and create webhook handlers
    const webhooks = {} as Record<string, WebhookHandler>;
    for (const [name, adapter] of Object.entries(config.adapters)) {
      this.adapters.set(name, adapter);
      // Create webhook handler for each adapter
      webhooks[name] = (request: Request, options?: WebhookOptions) =>
        this.handleWebhook(name, request, options);
    }
    this.webhooks = webhooks as Webhooks<TAdapters>;

    this.logger.debug("Chat instance created", {
      adapters: Object.keys(config.adapters),
    });
  }

  /**
   * Handle a webhook request for a specific adapter.
   * Automatically initializes adapters on first call.
   */
  private async handleWebhook(
    adapterName: string,
    request: Request,
    options?: WebhookOptions,
  ): Promise<Response> {
    // Ensure initialization
    await this.ensureInitialized();

    const adapter = this.adapters.get(adapterName);
    if (!adapter) {
      return new Response(`Unknown adapter: ${adapterName}`, { status: 404 });
    }

    return adapter.handleWebhook(request, options);
  }

  /**
   * Ensure the chat instance is initialized.
   * This is called automatically before handling webhooks.
   */
  private async ensureInitialized(): Promise<void> {
    if (this.initialized) {
      return;
    }

    // Avoid concurrent initialization
    if (!this.initPromise) {
      this.initPromise = this.doInitialize();
    }

    await this.initPromise;
  }

  private async doInitialize(): Promise<void> {
    this.logger.info("Initializing chat instance...");
    await this._stateAdapter.connect();
    this.logger.debug("State connected");

    const initPromises = Array.from(this.adapters.values()).map(
      async (adapter) => {
        this.logger.debug("Initializing adapter", adapter.name);
        const result = await adapter.initialize(this);
        this.logger.debug("Adapter initialized", adapter.name);
        return result;
      },
    );
    await Promise.all(initPromises);

    this.initialized = true;
    this.logger.info("Chat instance initialized", {
      adapters: Array.from(this.adapters.keys()),
    });
  }

  /**
   * Gracefully shut down the chat instance.
   */
  async shutdown(): Promise<void> {
    this.logger.info("Shutting down chat instance...");
    await this._stateAdapter.disconnect();
    this.initialized = false;
    this.initPromise = null;
    this.logger.info("Chat instance shut down");
  }

  /**
   * Initialize the chat instance and all adapters.
   * This is called automatically when handling webhooks, but can be called
   * manually for non-webhook use cases (e.g., Gateway listeners).
   */
  async initialize(): Promise<void> {
    await this.ensureInitialized();
  }

  /**
   * Register a handler for new @-mentions of the bot.
   *
   * **Important**: This handler is ONLY called for mentions in **unsubscribed** threads.
   * Once a thread is subscribed (via `thread.subscribe()`), subsequent messages
   * including @-mentions go to `onSubscribedMessage` handlers instead.
   *
   * To detect mentions in subscribed threads, check `message.isMention`:
   *
   * @example
   * ```typescript
   * // Handle new mentions (unsubscribed threads only)
   * chat.onNewMention(async (thread, message) => {
   *   await thread.subscribe();  // Subscribe to follow-up messages
   *   await thread.post("Hello! I'll be watching this thread.");
   * });
   *
   * // Handle all messages in subscribed threads
   * chat.onSubscribedMessage(async (thread, message) => {
   *   if (message.isMention) {
   *     // User @-mentioned us in a thread we're already watching
   *     await thread.post("You mentioned me again!");
   *   }
   * });
   * ```
   */
  onNewMention(handler: MentionHandler<TState>): void {
    this.mentionHandlers.push(handler);
    this.logger.debug("Registered mention handler");
  }

  /**
   * Register a handler for messages matching a regex pattern.
   *
   * @param pattern - Regular expression to match against message text
   * @param handler - Handler called when pattern matches
   *
   * @example
   * ```typescript
   * // Match messages starting with "!help"
   * chat.onNewMessage(/^!help/, async (thread, message) => {
   *   await thread.post("Available commands: !help, !status, !ping");
   * });
   * ```
   */
  onNewMessage(pattern: RegExp, handler: MessageHandler<TState>): void {
    this.messagePatterns.push({ pattern, handler });
    this.logger.debug("Registered message pattern handler", {
      pattern: pattern.toString(),
    });
  }

  /**
   * Register a handler for messages in subscribed threads.
   *
   * Called for all messages in threads that have been subscribed via `thread.subscribe()`.
   * This includes:
   * - Follow-up messages from users
   * - Messages that @-mention the bot (check `message.isMention`)
   *
   * Does NOT fire for:
   * - The message that triggered the subscription (e.g., the initial @mention)
   * - Messages sent by the bot itself
   *
   * @example
   * ```typescript
   * chat.onSubscribedMessage(async (thread, message) => {
   *   // Handle all follow-up messages
   *   if (message.isMention) {
   *     // User @-mentioned us in a subscribed thread
   *   }
   *   await thread.post(`Got your message: ${message.text}`);
   * });
   * ```
   */
  onSubscribedMessage(handler: SubscribedMessageHandler<TState>): void {
    this.subscribedMessageHandlers.push(handler);
    this.logger.debug("Registered subscribed message handler");
  }

  /**
   * Register a handler for reaction events.
   *
   * @example
   * ```typescript
   * // Handle specific emoji using EmojiValue objects (recommended)
   * chat.onReaction([emoji.thumbs_up, emoji.heart], async (event) => {
   *   if (event.emoji === emoji.thumbs_up) {
   *     console.log("Thumbs up!");
   *   }
   * });
   *
   * // Handle all reactions
   * chat.onReaction(async (event) => {
   *   console.log(`${event.added ? "Added" : "Removed"} ${event.emoji.name}`);
   * });
   * ```
   *
   * @param emojiOrHandler - Either an array of emoji to filter (EmojiValue or string), or the handler
   * @param handler - The handler (if emoji filter is provided)
   */
  onReaction(handler: ReactionHandler): void;
  onReaction(emoji: EmojiFilter[], handler: ReactionHandler): void;
  onReaction(
    emojiOrHandler: EmojiFilter[] | ReactionHandler,
    handler?: ReactionHandler,
  ): void {
    if (typeof emojiOrHandler === "function") {
      // No emoji filter - handle all reactions
      this.reactionHandlers.push({ emoji: [], handler: emojiOrHandler });
      this.logger.debug("Registered reaction handler for all emoji");
    } else if (handler) {
      // Specific emoji filter
      this.reactionHandlers.push({ emoji: emojiOrHandler, handler });
      this.logger.debug("Registered reaction handler", {
        emoji: emojiOrHandler.map((e) => (typeof e === "string" ? e : e.name)),
      });
    }
  }

  /**
   * Register a handler for action events (button clicks in cards).
   *
   * @example
   * ```typescript
   * // Handle specific action
   * chat.onAction("approve", async (event) => {
   *   await event.thread.post("Approved!");
   * });
   *
   * // Handle multiple actions
   * chat.onAction(["approve", "reject"], async (event) => {
   *   if (event.actionId === "approve") {
   *     await event.thread.post("Approved!");
   *   } else {
   *     await event.thread.post("Rejected!");
   *   }
   * });
   *
   * // Handle all actions (catch-all)
   * chat.onAction(async (event) => {
   *   console.log(`Action: ${event.actionId}`);
   * });
   * ```
   *
   * @param actionIdOrHandler - Either an action ID, array of action IDs, or the handler
   * @param handler - The handler (if action ID filter is provided)
   */
  onAction(handler: ActionHandler): void;
  onAction(actionId: string, handler: ActionHandler): void;
  onAction(actionIds: string[], handler: ActionHandler): void;
  onAction(
    actionIdOrHandler: string | string[] | ActionHandler,
    handler?: ActionHandler,
  ): void {
    if (typeof actionIdOrHandler === "function") {
      // No action filter - handle all actions
      this.actionHandlers.push({ actionIds: [], handler: actionIdOrHandler });
      this.logger.debug("Registered action handler for all actions");
    } else if (handler) {
      // Specific action ID(s) filter
      const actionIds = Array.isArray(actionIdOrHandler)
        ? actionIdOrHandler
        : [actionIdOrHandler];
      this.actionHandlers.push({ actionIds, handler });
      this.logger.debug("Registered action handler", { actionIds });
    }
  }

  onModalSubmit(handler: ModalSubmitHandler): void;
  onModalSubmit(callbackId: string, handler: ModalSubmitHandler): void;
  onModalSubmit(callbackIds: string[], handler: ModalSubmitHandler): void;
  onModalSubmit(
    callbackIdOrHandler: string | string[] | ModalSubmitHandler,
    handler?: ModalSubmitHandler,
  ): void {
    if (typeof callbackIdOrHandler === "function") {
      this.modalSubmitHandlers.push({
        callbackIds: [],
        handler: callbackIdOrHandler,
      });
      this.logger.debug("Registered modal submit handler for all modals");
    } else if (handler) {
      const callbackIds = Array.isArray(callbackIdOrHandler)
        ? callbackIdOrHandler
        : [callbackIdOrHandler];
      this.modalSubmitHandlers.push({ callbackIds, handler });
      this.logger.debug("Registered modal submit handler", { callbackIds });
    }
  }

  onModalClose(handler: ModalCloseHandler): void;
  onModalClose(callbackId: string, handler: ModalCloseHandler): void;
  onModalClose(callbackIds: string[], handler: ModalCloseHandler): void;
  onModalClose(
    callbackIdOrHandler: string | string[] | ModalCloseHandler,
    handler?: ModalCloseHandler,
  ): void {
    if (typeof callbackIdOrHandler === "function") {
      this.modalCloseHandlers.push({
        callbackIds: [],
        handler: callbackIdOrHandler,
      });
      this.logger.debug("Registered modal close handler for all modals");
    } else if (handler) {
      const callbackIds = Array.isArray(callbackIdOrHandler)
        ? callbackIdOrHandler
        : [callbackIdOrHandler];
      this.modalCloseHandlers.push({ callbackIds, handler });
      this.logger.debug("Registered modal close handler", { callbackIds });
    }
  }

  /**
   * Get an adapter by name with type safety.
   */
  getAdapter<K extends keyof TAdapters>(name: K): TAdapters[K] {
    return this.adapters.get(name as string) as TAdapters[K];
  }

  /**
   * Get a JSON.parse reviver function that automatically deserializes
   * chat:Thread and chat:Message objects.
   *
   * Use this when parsing JSON that contains serialized Thread or Message objects
   * (e.g., from workflow engine payloads).
   *
   * @returns A reviver function for JSON.parse
   *
   * @example
   * ```typescript
   * // Parse workflow payload with automatic deserialization
   * const data = JSON.parse(payload, chat.reviver());
   *
   * // data.thread is now a ThreadImpl instance
   * // data.message is now a Message object with Date fields restored
   * await data.thread.post("Hello from workflow!");
   * ```
   */
  reviver(): (key: string, value: unknown) => unknown {
    // eslint-disable-next-line @typescript-eslint/no-this-alias
    const chat = this;
    return function reviver(_key: string, value: unknown): unknown {
      if (value && typeof value === "object" && "_type" in value) {
        const typed = value as { _type: string };
        if (typed._type === "chat:Thread") {
          return ThreadImpl.fromJSON(chat, value as SerializedThread);
        }
        if (typed._type === "chat:Message") {
          return Message.fromJSON(value as SerializedMessage);
        }
      }
      return value;
    };
  }

  // ChatInstance interface implementations

  /**
   * Process an incoming message from an adapter.
   * Handles waitUntil registration and error catching internally.
   * Adapters should call this instead of handleIncomingMessage directly.
   */
  processMessage(
    adapter: Adapter,
    threadId: string,
    messageOrFactory: Message | (() => Promise<Message>),
    options?: WebhookOptions,
  ): void {
    const task = (async () => {
      const message =
        typeof messageOrFactory === "function"
          ? await messageOrFactory()
          : messageOrFactory;
      await this.handleIncomingMessage(adapter, threadId, message);
    })().catch((err) => {
      this.logger.error("Message processing error", { error: err, threadId });
    });

    if (options?.waitUntil) {
      options.waitUntil(task);
    }
  }

  /**
   * Process an incoming reaction event from an adapter.
   * Handles waitUntil registration and error catching internally.
   */
  processReaction(
    event: Omit<ReactionEvent, "adapter" | "thread"> & { adapter?: Adapter },
    options?: WebhookOptions,
  ): void {
    const task = this.handleReactionEvent(event).catch((err) => {
      this.logger.error("Reaction processing error", {
        error: err,
        emoji: event.emoji,
        messageId: event.messageId,
      });
    });

    if (options?.waitUntil) {
      options.waitUntil(task);
    }
  }

  /**
   * Process an incoming action event (button click) from an adapter.
   * Handles waitUntil registration and error catching internally.
   */
  processAction(
    event: Omit<ActionEvent, "thread" | "openModal"> & { adapter: Adapter },
    options?: WebhookOptions,
  ): void {
    const task = this.handleActionEvent(event).catch((err) => {
      this.logger.error("Action processing error", {
        error: err,
        actionId: event.actionId,
        messageId: event.messageId,
      });
    });

    if (options?.waitUntil) {
      options.waitUntil(task);
    }
  }

  async processModalSubmit(
    event: Omit<ModalSubmitEvent, "thread">,
    _options?: WebhookOptions,
  ): Promise<ModalResponse | undefined> {
    this.logger.debug("Incoming modal submit", {
      adapter: event.adapter.name,
      callbackId: event.callbackId,
      viewId: event.viewId,
      user: event.user.userName,
    });

    // Run matching handlers, return first response
    for (const { callbackIds, handler } of this.modalSubmitHandlers) {
      if (callbackIds.length === 0 || callbackIds.includes(event.callbackId)) {
        try {
          const response = await handler(event as ModalSubmitEvent);
          if (response) {
            return response;
          }
        } catch (err) {
          this.logger.error("Modal submit handler error", {
            error: err,
            callbackId: event.callbackId,
          });
        }
      }
    }
  }

  processModalClose(
    event: Omit<ModalCloseEvent, "thread">,
    options?: WebhookOptions,
  ): void {
    const task = (async () => {
      this.logger.debug("Incoming modal close", {
        adapter: event.adapter.name,
        callbackId: event.callbackId,
        viewId: event.viewId,
        user: event.user.userName,
      });

      for (const { callbackIds, handler } of this.modalCloseHandlers) {
        if (
          callbackIds.length === 0 ||
          callbackIds.includes(event.callbackId)
        ) {
          await handler(event as ModalCloseEvent);
        }
      }
    })().catch((err) => {
      this.logger.error("Modal close handler error", {
        error: err,
        callbackId: event.callbackId,
      });
    });

    if (options?.waitUntil) {
      options.waitUntil(task);
    }
  }

  /**
   * Handle an action event internally.
   */
  private async handleActionEvent(
    event: Omit<ActionEvent, "thread" | "openModal"> & { adapter: Adapter },
  ): Promise<void> {
    this.logger.debug("Incoming action", {
      adapter: event.adapter.name,
      actionId: event.actionId,
      value: event.value,
      user: event.user.userName,
      messageId: event.messageId,
      threadId: event.threadId,
    });

    // Skip actions from self (shouldn't happen, but be safe)
    if (event.user.isMe) {
      this.logger.debug("Skipping action from self", {
        actionId: event.actionId,
      });
      return;
    }

    // Create thread for the action event
    const isSubscribed = await this._stateAdapter.isSubscribed(event.threadId);
    const thread = await this.createThread(
      event.adapter,
      event.threadId,
      {} as Message,
      isSubscribed,
    );

    // Build full event with thread and openModal helper
    const fullEvent: ActionEvent = {
      ...event,
      thread,
      openModal: async (modal) => {
        if (!event.triggerId) {
          this.logger.warn("Cannot open modal: no triggerId available");
          return undefined;
        }
        if (!event.adapter.openModal) {
          this.logger.warn(
            `Cannot open modal: ${event.adapter.name} does not support modals`,
          );
          return undefined;
        }

        // Convert JSX to ModalElement if needed (same pattern as thread.post)
        let modalElement: ModalElement = modal as ModalElement;
        if (isJSX(modal)) {
          const converted = toModalElement(modal);
          if (!converted) {
            throw new Error("Invalid JSX element: must be a Modal element");
          }
          modalElement = converted;
        }

        return event.adapter.openModal(event.triggerId, modalElement);
      },
    };

    // Run matching handlers
    this.logger.debug("Checking action handlers", {
      handlerCount: this.actionHandlers.length,
      actionId: event.actionId,
    });

    for (const { actionIds, handler } of this.actionHandlers) {
      // If no action ID filter, run handler for all actions
      if (actionIds.length === 0) {
        this.logger.debug("Running catch-all action handler");
        await handler(fullEvent);
        continue;
      }

      // Check if the action matches any of the specified action IDs
      if (actionIds.includes(event.actionId)) {
        this.logger.debug("Running matched action handler", {
          actionId: event.actionId,
        });
        await handler(fullEvent);
      }
    }
  }

  /**
   * Handle a reaction event internally.
   */
  private async handleReactionEvent(
    event: Omit<ReactionEvent, "adapter" | "thread"> & { adapter?: Adapter },
  ): Promise<void> {
    this.logger.debug("Incoming reaction", {
      adapter: event.adapter?.name,
      emoji: event.emoji,
      rawEmoji: event.rawEmoji,
      added: event.added,
      user: event.user.userName,
      messageId: event.messageId,
      threadId: event.threadId,
    });

    // Skip reactions from self
    if (event.user.isMe) {
      this.logger.debug("Skipping reaction from self", {
        emoji: event.emoji,
      });
      return;
    }

    // Adapter is required for thread creation
    if (!event.adapter) {
      this.logger.error("Reaction event missing adapter");
      return;
    }

    // Create thread for the reaction event
    const isSubscribed = await this._stateAdapter.isSubscribed(event.threadId);
    const thread = await this.createThread(
      event.adapter,
      event.threadId,
      event.message ?? ({} as Message),
      isSubscribed,
    );

    // Build full event with thread and adapter
    const fullEvent: ReactionEvent = {
      ...event,
      adapter: event.adapter,
      thread,
    };

    // Run matching handlers
    this.logger.debug("Checking reaction handlers", {
      handlerCount: this.reactionHandlers.length,
      emoji: event.emoji.name,
      rawEmoji: event.rawEmoji,
    });

    for (const { emoji: emojiFilter, handler } of this.reactionHandlers) {
      // If no emoji filter, run handler for all reactions
      if (emojiFilter.length === 0) {
        this.logger.debug("Running catch-all reaction handler");
        await handler(fullEvent);
        continue;
      }

      // Check if the reaction matches any of the specified emoji
      const matches = emojiFilter.some((filter) => {
        // EmojiValue object identity comparison (recommended)
        if (filter === fullEvent.emoji) return true;

        // String comparison: check against emoji name or rawEmoji
        const filterName = typeof filter === "string" ? filter : filter.name;
        return (
          filterName === fullEvent.emoji.name ||
          filterName === fullEvent.rawEmoji
        );
      });

      this.logger.debug("Reaction filter check", {
        filterEmoji: emojiFilter.map((e) =>
          typeof e === "string" ? e : e.name,
        ),
        eventEmoji: fullEvent.emoji.name,
        matches,
      });

      if (matches) {
        this.logger.debug("Running matched reaction handler");
        await handler(fullEvent);
      }
    }
  }

  getState(): StateAdapter {
    return this._stateAdapter;
  }

  getUserName(): string {
    return this.userName;
  }

  getLogger(prefix?: string): Logger {
    if (prefix) {
      return this.logger.child(prefix);
    }
    return this.logger;
  }

  /**
   * Open a direct message conversation with a user.
   *
   * Accepts either a user ID string or an Author object (from message.author or event.user).
   *
   * The adapter is automatically inferred from the userId format:
   * - Slack: `U...` (e.g., "U03STHCA1JM")
   * - Teams: `29:...` (e.g., "29:198PbJuw...")
   * - Google Chat: `users/...` (e.g., "users/117994873354375860089")
   * - Discord: numeric snowflake (e.g., "1033044521375764530")
   *
   * @param user - Platform-specific user ID string, or an Author object
   * @returns A Thread that can be used to post messages
   *
   * @example
   * ```ts
   * // Using user ID directly
   * const dmThread = await chat.openDM("U123456");
   * await dmThread.post("Hello via DM!");
   *
   * // Using Author object from a message
   * chat.onSubscribedMessage(async (thread, message) => {
   *   const dmThread = await chat.openDM(message.author);
   *   await dmThread.post("Hello via DM!");
   * });
   * ```
   */
  async openDM(user: string | Author): Promise<Thread<TState>> {
    const userId = typeof user === "string" ? user : user.userId;
    const adapter = this.inferAdapterFromUserId(userId);
    if (!adapter.openDM) {
      throw new ChatError(
        `Adapter "${adapter.name}" does not support openDM`,
        "NOT_SUPPORTED",
      );
    }

    const threadId = await adapter.openDM(userId);
    return this.createThread(adapter, threadId, {} as Message, false);
  }

  /**
   * Infer which adapter to use based on the userId format.
   */
  private inferAdapterFromUserId(userId: string): Adapter {
    // Google Chat: users/123456789
    if (userId.startsWith("users/")) {
      const adapter = this.adapters.get("gchat");
      if (adapter) return adapter;
    }

    // Teams: 29:base64string...
    if (userId.startsWith("29:")) {
      const adapter = this.adapters.get("teams");
      if (adapter) return adapter;
    }

    // Slack: U followed by alphanumeric (e.g., U03STHCA1JM)
    if (/^U[A-Z0-9]+$/i.test(userId)) {
      const adapter = this.adapters.get("slack");
      if (adapter) return adapter;
    }

    // Discord: snowflake ID (17-19 digit number)
    if (/^\d{17,19}$/.test(userId)) {
      const adapter = this.adapters.get("discord");
      if (adapter) return adapter;
    }

    throw new ChatError(
      `Cannot infer adapter from userId "${userId}". Expected format: Slack (U...), Teams (29:...), Google Chat (users/...), or Discord (numeric snowflake).`,
      "UNKNOWN_USER_ID_FORMAT",
    );
  }

  /**
   * Handle an incoming message from an adapter.
   * This is called by adapters when they receive a webhook.
   *
   * The Chat class handles common concerns centrally:
   * - Deduplication: Same message may arrive multiple times (e.g., Slack sends
   *   both `message` and `app_mention` events, GChat sends direct webhook + Pub/Sub)
   * - Bot filtering: Messages from the bot itself are skipped
   * - Locking: Only one instance processes a thread at a time
   */
  async handleIncomingMessage(
    adapter: Adapter,
    threadId: string,
    message: Message,
  ): Promise<void> {
    this.logger.debug("Incoming message", {
      adapter: adapter.name,
      threadId,
      messageId: message.id,
      text: message.text,
      author: message.author.userName,
      authorUserId: message.author.userId,
      isBot: message.author.isBot,
      isMe: message.author.isMe,
    });

    // Skip messages from self (bot's own messages)
    if (message.author.isMe) {
      this.logger.debug("Skipping message from self (isMe=true)", {
        adapter: adapter.name,
        threadId,
        author: message.author.userName,
      });
      return;
    }

    // Deduplicate messages - same message can arrive via multiple paths
    // (e.g., Slack message + app_mention events, GChat direct webhook + Pub/Sub)
    const dedupeKey = `dedupe:${adapter.name}:${message.id}`;
    const alreadyProcessed = await this._stateAdapter.get<boolean>(dedupeKey);
    if (alreadyProcessed) {
      this.logger.debug("Skipping duplicate message", {
        adapter: adapter.name,
        messageId: message.id,
      });
      return;
    }
    await this._stateAdapter.set(dedupeKey, true, DEDUPE_TTL_MS);

    // Try to acquire lock on thread
    const lock = await this._stateAdapter.acquireLock(
      threadId,
      DEFAULT_LOCK_TTL_MS,
    );
    if (!lock) {
      this.logger.warn("Could not acquire lock on thread", { threadId });
      throw new LockError(
        `Could not acquire lock on thread ${threadId}. Another instance may be processing.`,
      );
    }

    this.logger.debug("Lock acquired", { threadId, token: lock.token });

    try {
      // Set isMention on the message for handler access
      // Preserve existing isMention if already set (e.g., from Gateway detection)
      message.isMention =
        message.isMention || this.detectMention(adapter, message);

      // Check if this is a subscribed thread first
      const isSubscribed = await this._stateAdapter.isSubscribed(threadId);
      this.logger.debug("Subscription check", {
        threadId,
        isSubscribed,
        subscribedHandlerCount: this.subscribedMessageHandlers.length,
      });

      // Create thread object (with subscription context for optimization)
      const thread = await this.createThread(
        adapter,
        threadId,
        message,
        isSubscribed,
      );

      if (isSubscribed) {
        this.logger.debug("Message in subscribed thread - calling handlers", {
          threadId,
          handlerCount: this.subscribedMessageHandlers.length,
        });
        await this.runHandlers(this.subscribedMessageHandlers, thread, message);
        return;
      }

      // Check for @-mention of bot
      if (message.isMention) {
        this.logger.debug("Bot mentioned", {
          threadId,
          text: message.text.slice(0, 100),
        });
        await this.runHandlers(this.mentionHandlers, thread, message);
        return;
      }

      // Check message patterns
      this.logger.debug("Checking message patterns", {
        patternCount: this.messagePatterns.length,
        patterns: this.messagePatterns.map((p) => p.pattern.toString()),
        messageText: message.text,
      });
      let matchedPattern = false;
      for (const { pattern, handler } of this.messagePatterns) {
        const matches = pattern.test(message.text);
        this.logger.debug("Pattern test", {
          pattern: pattern.toString(),
          text: message.text,
          matches,
        });
        if (matches) {
          this.logger.debug("Message matched pattern - calling handler", {
            pattern: pattern.toString(),
          });
          matchedPattern = true;
          await handler(thread, message);
        }
      }

      // Log if no handlers matched
      if (!matchedPattern) {
        this.logger.debug("No handlers matched message", {
          threadId,
          text: message.text.slice(0, 100),
        });
      }
    } finally {
      await this._stateAdapter.releaseLock(lock);
      this.logger.debug("Lock released", { threadId });
    }
  }

  private async createThread(
    adapter: Adapter,
    threadId: string,
    initialMessage: Message,
    isSubscribedContext = false,
  ): Promise<Thread<TState>> {
    // Parse thread ID to get channel info
    // Format: "adapter:channel:thread"
    const parts = threadId.split(":");
    const channelId = parts[1] || "";

    // Check if this is a DM
    const isDM = adapter.isDM?.(threadId) ?? false;

    return new ThreadImpl<TState>({
      id: threadId,
      adapter,
      channelId,
      stateAdapter: this._stateAdapter,
      initialMessage,
      isSubscribedContext,
      isDM,
      currentMessage: initialMessage,
      streamingUpdateIntervalMs: this._streamingUpdateIntervalMs,
    });
  }

  /**
   * Detect if the bot was mentioned in the message.
   * All adapters normalize mentions to @name format, so we just check for @username.
   */
  private detectMention(adapter: Adapter, message: Message): boolean {
    const botUserName = adapter.userName || this.userName;
    const botUserId = adapter.botUserId;

    // Primary check: @username format (normalized by all adapters)
    const usernamePattern = new RegExp(
      `@${this.escapeRegex(botUserName)}\\b`,
      "i",
    );
    if (usernamePattern.test(message.text)) {
      return true;
    }

    // Fallback: check for user ID mention if available (e.g., @U_BOT_123)
    if (botUserId) {
      const userIdPattern = new RegExp(
        `@${this.escapeRegex(botUserId)}\\b`,
        "i",
      );
      if (userIdPattern.test(message.text)) {
        return true;
      }

      // Discord format: <@USER_ID> or <@!USER_ID>
      const discordPattern = new RegExp(
        `<@!?${this.escapeRegex(botUserId)}>`,
        "i",
      );
      if (discordPattern.test(message.text)) {
        return true;
      }
    }

    return false;
  }

  private escapeRegex(str: string): string {
    return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }

  private async runHandlers(
    handlers: Array<
      (thread: Thread<TState>, message: Message) => Promise<void>
    >,
    thread: Thread<TState>,
    message: Message,
  ): Promise<void> {
    for (const handler of handlers) {
      await handler(thread, message);
    }
  }
}
